`timescale 1ns/1ps

module tb_top;

    reg clk;
    reg [1:0] x;
    wire y;

    reg [2:0] x_act;
    reg [2:0] x_ant;
    integer i;
    integer contador;


    MyFSM dut (
        .clk(clk),
        .x(x),
        .y(y)
    );


    // Reloj
    initial clk = 0;
    always #5 clk = ~clk;

    // Monitor
    always @(posedge clk) begin
      $display("Time=%0t | x=%b y=%b c=%b", $time,  x, y, contador);
      $display("x_act=%b x_ant=%b ", x_act, x_ant);
    end

    // Self check
    initial begin
        $display("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        contador = 0;
        x_ant = 0;
        x_act = 0;
        
        for( i = 0 ; i <= 4 ; i = i+1 ) begin

            for( x_act = 0 ; x_act <= i ; x_act = x_act+1 ) begin

                #10 x = x_act;
                x_ant = x_act;

                // lofica de la variable interna
                if( contador == 0)  
                    if ( x_act == 1) contador = 1 ;
                else 
                    if( x_act == (x_ant + 1) ) contador = contador + 1;
                    else contador = 0;

                // Self check
                if( y == 1 && contador != 0 )
                    $error("FAIL: La variable y está activa, pero el contador no llego a 3");

                if(contador == 3  && y != 1 )
                    $error("FAIL: El contador llego a 3, pero la salida está en bajo");

                if(contador == 3  && y == 1 )
                    $display("PASS: el contador llego a 3 y la salida está en alto  ");
            end 
        end
    
        #20;
        $stop;
    end
 

  covergroup cg_fsm @(posedge clk);

      coverpoint x {
        bins cero = {00};
        bins uno  = {01};
        bins dos  = {10};
        bins tres  = {10};
      }

      coverpoint y { 
        bins cero = {0};
        bins uno  = {1};
      }
  endgroup

  cg_fsm cs = new();
    
  initial begin
    $dumpfile("dump.vcd");
    $dumpvars;
    $assertvacuousoff(0); 
  end

endmodule
